java.lang.AssertionError: (
(_ = {}, other list = []) ⇒ [], 
(_ = {}, other list = []) ⇒ {}, 
{
 (list == other list) = ((
   usage examples = [[] == [], [1] == [1], [true] == [true], [1] == [] == false, [2] == [2, 3] == false], 
   _ = "Test equality of lists.\n\nLists are considered equal if they have the same number of elements and\neach element is equal to the element from the other list at the same\nposition.\n\nLists cannot be compared using `==` unless the elements in one list\ncan be compared to the corresponding elements of the other list using\n`==`.\n"
 ) ⇒ (
   (list element, remaining list elements) ↦ (
     (other list element, remaining other list elements) ↦ 
       list element == other list element ∧ remaining list elements == remaining other list elements ?: false) ∘ other list) ∘ list ?: other list.is empty), 
 list.comma separated = ((_ = "Convert each element to a string using its `.label` method.\n\nThen, join elements together using \", \".\n\nIf the list is empty, returns an empty list.  Otherwise, returns\na single-element list with the result of the concatenation.\n") ⇒ (.label ∘ list).sum),
 list.core type selector(__target) = __target.list(list, {}, list, list),
 list.difference = ((_ = "Combine elements in a list using subtraction.\n\nIf the list has zero or one elements, the result is the\nsame list.\n\nIf the list has two elements, the result is a single-element\nlist with the first element less the second.\n\nIf the list has three or more elements, the result is a\nsingle-element list with the first element less the sum\nof the remaining elements.\n") ⇒ (usage examples = [[].difference == [], [123].difference == [123], [123, 100].difference == [23], [77, 7, 20].difference == [50], [77, 1, 1, 1, 1, 1, 1, 1].difference == [70]]) ⇒ (list.first + list.after first.sum).combine using binary operator((list.first + list.after first.sum).combine using binary operator, {}, (list.first + list.after first.sum).combine using binary operator, .\-)),
 list.exponentiation = ((_ = "Combine elements in a list using exponentation.\n\nIf the list is empty or has only a single element, this returns\nthe list unchanged.\n\nIf the list has two elements, the result is a single-element list\ncontaining the first element raised to the power of the second in a \nsingle-element list.\n\nIf the list has three or more elements, the result is \na single-element list containing the first element raised to the \npower of the product of the remaining elements. \n") ⇒ (example usage = [[9, 3].exponentation == [729], [7].exponentation == [7], [].exponentation == [], [3, 2, 2].exponentation == [81], [2, 2, 1, 2, 2].exponentation == [256]]) ⇒ (list.first + list.after first.product).combine using binary operator((list.first + list.after first.product).combine using binary operator, {}, (list.first + list.after first.product).combine using binary operator, .to the power of)),
 list.label = "[" + (list.comma separated ?: "") + "]",
 list.max = ((_ = "The maximum element of the list as defined by the element(s)\nown `<` operator(s).\n\nIf the list is empty or has only a single element, this is\nthe list unchanged.\n\nIf the list has two or more elements, this is a single-element\nlist containing the maximum element, determined by comparing\nelements in an unspecified order using their `<` operator.\n") ⇒ (example usage = [[9, 3].max == [9], [7].max == [7], [].max == [], [3, -1, 2].max == [3], [2, 2, 1, 2, 2] == [2]]) ⇒ list.combine using binary operator(list.combine using binary operator, {}, list.combine using binary operator, x ↦ y ↦ if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y)(if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), y)(if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y)(if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), y), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y)(if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), y), x))), list.min = ((_ = "The minimum element of the list as defined by the element(s)\nown `<` operator(s).\n\nIf the list is empty or has only a single element, this is\nthe list unchanged.\n\nIf the list has two or more elements, this is a single-element\nlist containing the minimum element, determined by comparing\nelements in an unspecified order using their `<` operator.\n") ⇒ (example usage = [[9, 3].min == [729], [7].min == [7], [].min == [], [3, 2, 2].min == [81], [2, 2, 1, 2, 2].min == [256]]) ⇒ list.combine using binary operator(list.combine using binary operator, {}, list.combine using binary operator, x ↦ y ↦ if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y)(if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), x)(if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y)(if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), x), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y)(if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, x < y), x), y))), 
 prefix.plus nonempty list(suffix) = list trait Φ {(list + other list) = if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty)(if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty), list)(if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty)(if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty), list), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty)(if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, other list.is empty), list), prefix + suffix + other list), (list == other list) = prefix == other list.to(other list.to, {}, other list.to, |prefix|) ∧ suffix == other list.from(other list.from, {}, other list.from, |prefix|), (list ?: sub) = ((_ = "`[a,b] ?: c == a`") ⇒ prefix ?: sub), after first = ((usage examples = [[1, 2].after first == [2], [1, 2, 3].after first == [2, 3], ([1] + [2, 3]).after first == [2, 3], ([1, 2] + [3]).after first == [2, 3]]) ⇒ prefix.after first + suffix), at(offset) = prefix.at(prefix.at, {}, prefix.at, offset) ∨ suffix.at(suffix.at, {}, suffix.at, offset - |prefix|), before last = ((usage examples = [[1, 2, 3].before last == [1, 2], ([1, 2] + [3]).before last == [1, 2], [1, 2].before last == [1]]) ⇒ prefix + suffix.before last), combine using binary operator(op) = ((_ = "Combine elements in a list using the given operator.\n  \nThe operator should be a curried binary operator, taking\nthe first parameter and returning a function that accepts\nthe second and returns the result.\n\nThe elements of the list should be of the same type.\n\nIf the list has zero or one elements it is returned\nunchanged.  Otherwise a list of length one is returned,\nwhich is the result of combining elements using the\ngiven operator in an unspecified order.\n\nBecause the order of combination is unspecified, the\noperator should be associative when used on lists\nwith more than two elements.\n\nNote that many standard methods and operators can be\npassed in simply by using a \"dot\" prefix, for example:\n\n* `.+` for addition\n* `.*` for multiplication\n* `.∧` for logical and\n\n") ⇒ (lhs list op in list = .\∘ ∘ lhs op in list, lhs op in list = op ∘ lhs in list, rhs in list = suffix.combine using binary operator(suffix.combine using binary operator, {}, suffix.combine using binary operator, op), lhs in list = prefix.combine using binary operator(prefix.combine using binary operator, {}, prefix.combine using binary operator, op)) ⇒ \◄(\◄, {}, \◄, rhs in list) ∘ lhs list op in list), first = ((_ = "A list containing only the the first element of this list.") ⇒ (usage examples = [[1, 2, 3].first == [1], [].first == [], [4, 4].first == [4], ([2] + [5]).first == [2]]) ⇒ prefix.first), list.from(offset) = prefix.from(prefix.from, {}, prefix.from, offset) + suffix.from(suffix.from, {}, suffix.from, offset - |prefix|), into(algebra) = prefix.into(prefix.into, {}, prefix.into, algebra) + suffix.into(suffix.into, {}, suffix.into, algebra), is empty = false, is nonempty = true, last = suffix.last ∨ prefix.last, segment(start, end) = prefix.segment(prefix.segment, {}, prefix.segment, start, end) + suffix.segment(suffix.segment, {}, suffix.segment, start - |prefix|, end - |prefix|), to(limit) = prefix.to(prefix.to, {}, prefix.to, limit) + suffix.to(suffix.to, {}, suffix.to, limit - |prefix|), (|list|) = |prefix| + |suffix|, (elt ∈ list) = elt ∈ prefix ∨ elt ∈ suffix, (f ∘ list) = f ∘ prefix + f ∘ suffix, (list ∧ other) = other, (list ∨ sub) = list}, list.product = ((_ = "Combine elements in a list using their multiplication operator.\n\nIf the list is empty or has only a single element,\nthis is the list itself.\n\nOtherwise, this is a single-element list containing\nthe result of combining the elements of the list using\nmultiplication.\n") ⇒ (usage examples = [[].product == [], [33].product == [33], [3, 11].product == [33], [7, 3, 3].product == [63]]) ⇒ list.combine using binary operator(list.combine using binary operator, {}, list.combine using binary operator, .\×)), list.quotient = ((_ = "Combine elements in a list using their division operator and\n`is zero` property.\n\nIf the list is empty or has only a single element, this returns\nthe list unchanged.\n\nIf the list has two or more elements and any of the elements\nafter the first is zero, this returns an empty list.  The\n`is zero` property is used to determine whether an element is\nzero.\n\nIf the list has two elements, this is a single-element list\ncontaining the first element divided by the second in a \nsingle-element list.\n\nIf the list has three or more elements, this is \na single-element list containing the first element divided \nby the product of the remaining elements. \n") ⇒ (example usage = [[9, 3].quotient == [3], [7].quotient == [7], [].quotient == [], [90, 9, 5].quotient == [2], [120, 4, 3, 10].quotient == [1]]) ⇒ if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first))(if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first)), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first)), []))((_ = "Combine elements in a list using their division operator and\n`is zero` property.\n\nIf the list is empty or has only a single element, this returns\nthe list unchanged.\n\nIf the list has two or more elements and any of the elements\nafter the first is zero, this returns an empty list.  The\n`is zero` property is used to determine whether an element is\nzero.\n\nIf the list has two elements, this is a single-element list\ncontaining the first element divided by the second in a \nsingle-element list.\n\nIf the list has three or more elements, this is \na single-element list containing the first element divided \nby the product of the remaining elements. \n") ⇒ (example usage = [[9, 3].quotient == [3], [7].quotient == [7], [].quotient == [], [90, 9, 5].quotient == [2], [120, 4, 3, 10].quotient == [1]]) ⇒ if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first))(if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first)), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first)), []), {}, (_ = "Combine elements in a list using their division operator and\n`is zero` property.\n\nIf the list is empty or has only a single element, this returns\nthe list unchanged.\n\nIf the list has two or more elements and any of the elements\nafter the first is zero, this returns an empty list.  The\n`is zero` property is used to determine whether an element is\nzero.\n\nIf the list has two elements, this is a single-element list\ncontaining the first element divided by the second in a \nsingle-element list.\n\nIf the list has three or more elements, this is \na single-element list containing the first element divided \nby the product of the remaining elements. \n") ⇒ (example usage = [[9, 3].quotient == [3], [7].quotient == [7], [].quotient == [], [90, 9, 5].quotient == [2], [120, 4, 3, 10].quotient == [1]]) ⇒ if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first))(if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first)), {}, if _ then _ else(if _ then _ else, {}, if _ then _ else, (.is zero).is true for any element of((.is zero).is true for any element of, {}, (.is zero).is true for any element of, list.after first)), []), (list.first + list.after first.product).combine using binary operator((list.first + list.after first.product).combine using binary operator, {}, (list.first + list.after first.product).combine using binary operator, .\÷)), list.sum = ((_ = "Combine elements in a list using addition.\n\nIf the list is empty or has only a single element,\nthis is the list itself.\n\nOtherwise, this is a single-element list containing\nthe result of combining the elements of the list using\naddition.\n") ⇒ (usage examples = [[].sum == [], [3].sum == [3], [1, 1].sum == [2], [1, 1, 1].sum == [3], [1, 1, 1, 1].sum == [4], [2, 3, 4, 5].sum == [14]]) ⇒ list.combine using binary operator(list.combine using binary operator, {}, list.combine using binary operator, .\+))
}).λ ?: ((_ = {}, other list = []) ⇒ other list.is empty)

(abc)
    at banjo.expr.core.test.BaseExprTest$1.fallback(BaseExprTest.java:58)
    at banjo.expr.core.test.BaseExprTest$1.fallback(BaseExprTest.java:1)
    at banjo.expr.core.BaseCoreExprVisitor.projection(BaseCoreExprVisitor.java:63)
    at banjo.expr.core.Projection.acceptVisitor(Projection.java:47)
    at banjo.expr.core.LazyCoreExpr.acceptVisitor(LazyCoreExpr.java:63)
    at banjo.expr.core.test.BaseExprTest.isTrue(BaseExprTest.java:55)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
    at org.junit.runners.Suite.runChild(Suite.java:127)
    at org.junit.runners.Suite.runChild(Suite.java:26)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)

